Ниже — цельная концепция PContext: как это собрать, где есть риски и какие решения/компромиссы я предлагаю. В конце — список уточняющих вопросов, чтобы убрать «белые пятна».

Общая идея

- PContext — это:
  - ядро-библиотека (декораторы, типы входов/возвратов, параметры, Ask, исполнение, логика сервисов),
  - менеджер с треем и UI (процессы, сервисы, параметры, логи, настройки),
  - интеграция с контекстным меню проводника (Windows) и файлового менеджера (Ubuntu),
  - регистратор скриптов (сканирование папки, установка deps, регистрация в системе меню),
  - рантайм-исполнитель (oneshot и сервисные вызовы).
- Скрипты располагаются в папке пользователя:
  - Windows: C:\Users\<user>\.pcontext\scripts (иконки: C:\Users\<user>\.pcontext\icons\{script_id}.ico)
  - Linux: ~/.pcontext/scripts и ~/.pcontext/icons/{script_id}.png
- Python ≥ 3.10, сборка в exe (Windows), приоритет — скорость и отзывчивость.

Архитектура компонентов

1. Ядро pcontext (Python-пакет)

- Декораторы и модели:
  - oneshot_script(...): метаданные (id, title, description, timeout, group), сигнатура — типы входов и Param-параметры.
  - service(...): класс сервиса с метаданными (id, title, description, timeout, max_downtime, on_startup).
  - service_script(...): методы сервиса, которые можно вызывать отдельным пунктом меню.
  - Param(...): типизированные параметры с ограничениями (ge, le, choices/Enum, pattern, default).
  - Типы входов: File, Folder, Image, Video, TXT, DOC, ARCHIVE, PYTHON, EXE, а также множественные варианты (Images, Videos, …) и конструкторы объединений (например, Image | Video). Для кастомных расширений — Extensions([...]).
  - Ask(Questions): декларативные формы по аннотированным полям (в основу можно положить Pydantic для валидации и автогенерации UI).
- Действия (возвраты из скриптов): Open, Text, Link, Copy, Notify, Folder, None. У каждого — единый интерфейс, сериализация для логов, повтор запуска действия (replay).
- Исполнение:
  - oneshot выполняется в отдельном процессе (с таймаутом).
  - service — длительный процесс с IPC; service_script вызывается через RPC; автостарт при необходимости.

2. Менеджер (демон + трей + UI) — единый процесс

- Запускается при старте пользователя (опционально), всегда показывает tray icon.
- Функции:
  - хранит реестр скриптов и параметров,
  - следит за сервисами, их жизненным циклом, таймаутами/простоем,
  - запускает oneshot’ы и роутит вызовы в сервисы,
  - обрабатывает возврат Action и выполняет его,
  - логирует все запуски (успех/ошибка), позволяет повторить действие (replay),
  - UI: «Запущенные сервисы», «Процессы», «Все скрипты и сервисы», «Настройки», «Логи».
- Локальное хранилище: SQLite (список скриптов, параметры, логи, состояния), файл в ~/.pcontext/pcontext.db (или %USERPROFILE%\.pcontext\pcontext.db).

3. Регистрация скриптов

- «Обновить» (в окне «Все скрипты и сервисы»):
  - рекурсивное сканирование папки scripts,
  - чтение верхнего докстринга для требований (requirements как в requirements.txt — кроме pcontext),
  - установка deps в отдельный venv скрипта (см. ниже),
  - импорт скрипта в изолированном процессе introspector для извлечения метаданных (декораторы, параметры и пр.),
  - запись/обновление записи в SQLite (с резетом параметров при изменениях),
  - перерегистрация пунктов контекстного меню в ОС.
- Идентификатор скрипта:
  - либо из декоратора id=..., либо стабильно генерируется из пути (например, превращая путь в dotted.name), чтобы легко сопоставлять иконки по id.
- Группировка:
  - соответствует структуре папок в scripts. Путь на примере: PContext -> Analyze -> Анализировать.

4. Изоляция зависимостей и старт процессов

- Чтобы не ловить конфликты зависимостей:
  - для каждого скрипта создаём собственный venv в ~/.pcontext/venvs/<script_id>,
  - ставим туда зависимости из докстринга + сам pcontext той же версии, что у менеджера,
  - oneshot и сервисы запускаем python из этого venv.
- Производительность:
  - oneshot — отдельный процесс (быстрое стартовое время зависит от venv, но с дешёвым импортом это ок),
  - сервисы — один процесс на сервис; методы — через RPC; при простое/таймауте сервисы гасим.

5. IPC между менеджером и сервисами/раннерами

- Лёгкий RPC поверх именованных каналов:
  - Windows: Named Pipes,
  - Linux: AF_UNIX сокеты.
- Формат: JSON или MessagePack.
- Почему не HTTP: лишняя тяжесть и дольше стартует; нам важна скорость.

6. Интеграция с контекстным меню

Windows 10/11 (legacy меню, как вы и указали)

- Регистрация без прав админа: в HKCU\Software\Classes\...
  - для файлов: HKCU\Software\Classes\*\shell\PContext
  - для папок: HKCU\Software\Classes\Directory\shell\PContext
  - фон папки: HKCU\Software\Classes\Directory\Background\shell\PContext
- Структура:
  - «PContext» как подменю (MUIVerb = "PContext", Icon — нашей программы),
  - SubCommands → список подкоманд из Explorer CommandStore (по одному на каждый скрипт/группу).
- Вызов:
  - каждая подкоманда — это команда вида: "...\pcontext.exe" run --id <script_id> --files %\*
  - %\* должен передать все выбранные элементы отдельными аргументами (Explorer обычно корректно кавычит).
- Фильтрация показа по типам (если хочется скрывать «неподходящие» пункты):
  - «идеально» это делается через COM IContextMenu (динамически решать по выделению), но это существенно усложняет проект,
  - «практически» можно частично фильтровать через AppliesTo (System.PerceivedType:="image" OR ...), либо по расширениям. Это работает, но не на 100% гибко, особенно для сложных комбинаций типов.
  - Предлагаю:
    - Фаза 1 (MVP): все включённые скрипты видны в подменю, в рантайме проверяем соответствие типам и даём понятную ошибку если не подходит,
    - Фаза 2 (опционально): частичный AppliesTo по расширениям/PerceivedType для сокрытия явно неподходящих мест,
    - Фаза 3 (опционально): собственное shell-расширение (C++) с IContextMenu для идеального UX (быстро и динамично), если это критично.
- Мультивыбор:
  - %_ обычно работает. В качестве резервного плана — PowerShell-«обёртка», но она медленнее. Я бы начал с %_ и зафиксировал это как требование, с авто-тестами на мультивыбор.

Linux (Ubuntu)

- Нацельтесь на Nautilus (GNOME Files), т.к. это дефолт в Ubuntu:
  - плагин на Python (python3-nautilus) — позволяет динамически формировать подменю «PContext» по текущему выделению,
  - плагин опрашивает наш менеджер по локальному сокету и получает список актуальных пунктов (с учётом типов, групп и настроек видимости).
- Альтернативно/дополнительно (если без плагина):
  - .desktop actions — статично и бедно; мало подходит под ваши требования,
  - Nemo/Thunar — позже, отдельными плагинами.

UI/Tray и окна

- Фреймворк: PySide6 (Qt 6). Причины: быстро, современно, красиво, стабильный трэй, нотификации через нативные API/бриджи.
- Окна трея:
  - Запущенные сервисы: список, кнопки «Остановить»/«Перезапустить», время простоя, uptime.
  - Процессы: активные oneshot, PID, таймаут, кнопка «Остановить».
  - Все скрипты и сервисы:
    - «Обновить»: ре-скан, пере-регистрация, пере-установка зависимостей при изменении,
    - список: id, тип (oneshot/service), title, description, чекбоксы «в меню» и «запускать при старте» (только если без входных файлов), кнопка «Параметры», кнопка «Запустить» (если без входных),
    - окно «Параметры»: автогенерируемая форма по Param (типам, ограничениям), «Сброс к дефолту», сохранение между перезапусками.
  - Настройки:
    - автозапуск PContext при входе в систему,
    - «отключить уведомления» (глобальный флаг).
  - Логи:
    - последние запуски: id запуска, имя скрипта, время, длительность, статус, кнопка «Повторить действие» (если успех).
    - При повторе действия — выполняем тот же Action (Open/Copy/Link/Notify/Text/Folder). Если вышла ошибка (например, файла нет) — информируем.
- Ask:
  - модальное окно по описанию класса Questions (Pydantic + Annotated), поля: str, int, float, bool, Enum, выбор файла/папки (с фильтром по типу), с валидацией.
  - Возврат в скрипт — объект с ответами или None (если отменено).

Исполнение скриптов и ошибки

- Любой запуск оборачиваем в try/except:
  - исключения сериализуются и показываются в нотификациях и логах (с кратким стек-трейсом),
  - статус «ошибка» и длительность — тоже логируются.
- Таймауты:
  - oneshot: жёстко прерываем дочерний процесс.
  - service: контролируем общий lifetime и «простой» (max_downtime) — если сервис не используется, гасим.
- Сервисная модель:
  - не полагаться на **del** для высвобождения: лучше определить явный on_stop() у сервиса; менеджер вызывает его при остановке.
  - Автозапуск зависимого сервиса: если вызывается yolo_service.detect → менеджер гарантирует, что yolo_service запущен (либо запускает), затем делает RPC-вызов метода.

Реестр, сохранения, иконки

- SQLite: таблицы scripts, services, params, runs, settings.
- Иконки для меню: если есть C:\Users\<user>\.pcontext\icons\{id}.ico — используем; иначе дефолт.
- Параметры скриптов храним JSON-ом (с типовой схемой/метаданными), восстанавливаем при старте программы.

Регистрация зависимостей (requirements в докстринге)

- При первом обнаружении или изменении скрипта:
  - парсим верхний докстринг, извлекаем requirements,
  - создаём/обновляем venv скрипта,
  - ставим зависимости (pip), плюс pcontext (той же версии),
  - затем запускаем короткий «интроспектор» в этом venv для извлечения метаданных (он импортирует файл; это допустимо и может быть «тяжеловато», но происходит только на «Обновить»).
- Оптимизация: кэшируем хэш файла и хэш списка deps, чтобы лишний раз ничего не переставлять.

Типы входов и соответствие

- Сопоставление по расширению (быстро) + (опционально) по MIME/PerceivedType/Kind (чтобы классифицировать лучше).
- Объединения типов (Image | Video), множественные (Images, Videos, ...), Extensions([...]) — всё сведём к набору признаков/паттернов.
- Проверка соответствия выполняется менеджером до старта; если не подходит — понятное уведомление пользователю.

Нотификации

- Windows: WinRT Toast (через winrt) или Windows 10 Toasts lib.
- Linux: libnotify (notify2).
- Глобальное выключение уведомлений в настройках — уважать везде, кроме критических диалогов.

Производительность и сборка

- Сборка под Windows:
  - PyInstaller — проще и быстрее интегрируется, но больше размер.
  - Nuitka — быстрее рантайм, меньше зависимостей, но более сложный билд-пайплайн. Я бы целился в Nuitka для релизов, PyInstaller для CI/пайтонского окружения и внутренних сборок.
- Быстрый старт:
  - менеджер — минимальные импорты на старте,
  - IPC — лёгкий,
  - контекстное меню — без тяжёлых прокладок (по возможности без PowerShell, с %\*).
- Возможный апгрейд для Windows: собственное Shell Extension (C++) для динамики меню и полной поддержки мультивыбора с идеально корректными кавычками и фильтрацией. Это повысит сложность, но и UX/скорость будут топ.

Улучшения/советы по API и UX

- Единообразие маркеров входов: лучше везде использовать вызов как конструктор: File(), Image(), Images() и т.д. (в примерах есть и Image, и Image()).
- Чёткий способ множественного ввода:
  - files: list[str] = Files() или images: list[str] = Images()
  - Альтернатива (круче): Many(Image()) — явное указание, что параметр — список этого типа.
- Enum в параметрах: API Param должен дружить с Enum (choices извлекаются автоматически).
- Сервис: рекомендую on_stop()/cleanup() вместо **del**, и явно документировать, что тяжёлые ресурсы освобождаются там.
- Ask: отличная идея. Я бы добавил:
  - валидационные сообщения под полями,
  - пресеты/шаблоны вопросов (например, простая форма «число в диапазоне»),
  - возможность «сохранить ответы как профиль по умолчанию» для конкретного скрипта.
- Регистрация:
  - при конфликте id — показать пользователю и предложить авто-ремап (например, дописать суффикс).
  - предупреждение, если скрипт не экспортирует ни одного декорированного объекта.
- Логи:
  - фильтры по статусу/дате/скрипту,
  - экспорт последнего лога с traceback (для диагностики).
- Политика автозапуска «скрипт/сервис при старте программы»:
  - работаем только если без входных данных; если есть Ask — опционально можно спросить «просто открыть окно Ask при старте?».

Риски и компромиссы

- Windows контекстное меню:
  - без собственного COM-расширения гибкость ограничена (динамическая фильтрация по текущему выделению, очень большие списки, хитрые условия).
  - Предлагаю стартовать с Registry + CommandStore + %\*, плюс «умная» логика в рантайме; COM — как фаза развития.
- Импорт скриптов при регистрации:
  - может быть тяжело, если внутри import’ы вроде torch/ultralytics. Это ок, т.к. происходит только при «Обновить». Можно подсказать авторам не тянуть тяжёлое на модульном уровне (переносить в **init**/run), чтобы всё было быстрее.
- Мультивыбор %\*:
  - в 99% — норм. Нужны авто-тесты на пробелы/юникод/большое число файлов. При проблемах — fallback через маленький «launcher», который считывает список из temp файла или использует PowerShell (медленнее, но надёжно).

Открытые вопросы (прошу подтвердить/уточнить)

1. Windows-меню:
   - Ок, если на первом этапе все скрипты видны всегда в подменю PContext (с возможностью частично скрывать по AppliesTo для типичных расширений), а строгая проверка типов будет на этапе запуска?
   - Мультивыбор через %\* приемлем как стартовое решение? Если наткнёмся на кейсы, добавим «надёжную» обёртку.
2. Linux:
   - Достаточно поддержать Nautilus (Ubuntu) на первом этапе? Nemo/Thunar — позже?
3. Изоляция deps:
   - Пер-скриптовые venv — ок? Это гарантирует отсутствие конфликтов, но увеличивает число venv. Альтернатива — общий venv (быстрее, но риск конфликтов).
4. Сервисный API:
   - Принимаем явный on_stop() вместо **del**?
   - Согласуем, что сервисы всегда живут в отдельном процессе (а не в потоке)?
5. Параметры:
   - Ок, если Param обязателен для настраиваемых параметров, а входные файлы/папки/типы идут через File()/Image()/…?
   - Нужен ли readonly-параметр (для отображения в UI, но без изменения)?
6. Ask:
   - Ок, если окно Ask блокирует выполнение скрипта до ответа/закрытия? Или нужна опция «не модальное» (например, для сборки пакетных задач)?
7. Уведомления:
   - При «force disable notifications» отключаем все тосты, кроме критических ошибок запуска? Или вообще все?
8. Логи и «повторить действие»:
   - Реплей Always? Для Text/Copy/Notify/Link/Open/Folder — это просто. Для действий, зависящих от временных файлов (например, Open временного изображения) — пользователю даём понятную ошибку и запись «файл не найден» — ок?
9. Автозапуск PContext:
   - Windows: ключ в HKCU\...\Run — достаточно?
   - Linux: systemd user service — ок?
10. UX и фреймворк UI:

- Подходит PySide6/Qt? Нужен ли QML (более «красиво») или достаточно виджетов (быстрее разработка)?

План поэтапной реализации

- Этап 1 (MVP, Windows и Ubuntu Nautilus):
  - Ядро pcontext (декораторы, типы, Param, Actions, Ask),
  - Менеджер + трей + базовые окна (списки, запуск/остановка, параметры, логи),
  - Регистрация скриптов (сканер, venv, deps из докстринга, интроспекция),
  - Интеграция с Windows через Registry + CommandStore + %\* (подменю PContext),
  - Nautilus-плагин на Python с динамическим меню (опрашивает менеджер),
  - Логи/реплей действий,
  - Сборка в exe (PyInstaller или Nuitka).
- Этап 2:
  - Улучшенная фильтрация меню по типам (AppliesTo в Windows по расширениям/PerceivedType),
  - File watcher (watchdog) для автоподсветки изменений (в дополнение к кнопке «Обновить»),
  - Более богатые виджеты параметров (Enum с иконками, слайдеры, цвет, и пр.).
- Этап 3 (опционально):
  - Windows Shell Extension (C++ IContextMenu) для идеально динамического меню и стабильного мультивыбора,
  - Поддержка Nemo/Thunar плагины,
  - Расширенные типы данных для Ask (дата/время, таблицы, теги и т.п.).

Что мне нравится и что бы я улучшил

- Нравится:
  - Простая и понятная декларация скриптов через декораторы, вдохновлённая FastAPI/Pydantic,
  - Идея разделения oneshot и service,
  - Ask как способ запрашивать интерактивные данные — мощно и универсально,
  - Возврат действий (Action) — отличная унификация UX.
- Предлагаю улучшить/уточнить:
  - Единообразие API типов входов (везде вызвать их: File(), Image() и т.д.),
  - Чёткая модель множественного выбора (Images()/Many(Image())) и объединений (Image() | Video()),
  - Явный on_stop() у сервиса вместо **del**,
  - Уточнить стратегию для Windows-меню: начать с простого (всегда показывать) и постепенно улучшать фильтрацию,
  - Встроенная проверка корректности id и детект дубликатов при регистрации,
  - Чёткая политика установки deps: только при изменениях; лог установки — в «Логи» с отдельной вкладкой «Установка зависимостей».

Если такой план и компромиссы вас устраивают — я соберу детальную спецификацию форматов (модель Script/Service/Param/Action, формат IPC, схема БД, структура реестра Windows, API плагина Nautilus) и тест-план. И после этого уже можно переходить к коду.

Жду ваших ответов на вопросы выше — это поможет убрать последние неопределённости и построить максимально точную реализацию.
