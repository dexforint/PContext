https://lmarena.ai/c/019a1640-0ac2-71a0-84b3-8b93c37fd251

Идея отличная. Это реально полезный инструмент, и синтаксис декораторов в духе FastAPI/Pydantic выглядит естественно. Ниже — тщательно проработанный план архитектуры, важные нюансы, риски и предложения по улучшениям. В конце — список вопросов, чтобы закрыть белые пятна.

Общий обзор

PContext — локальный диспетчер Python-скриптов и сервисов, интегрированный в контекстное меню Проводника (Windows) и файловых менеджеров (Linux), с системным треем, параметрами, логами, уведомлениями и управлением зависимостями.
Скрипты лежат в папке пользователя, регистрируются PContext, появляются в подменю PContext с вложенными группами, запускаются на выбранных файлах/папках или в пустой области.
Сервисы — долгоживущие процессы с собственными параметрами и таймаутами, к которым обращаются скрипты.
Есть унифицированные действия на выходе (Open, Text, Link, Copy, Notify, Folder, None) и интерактивная форма Ask.
Ключевые моменты дизайна

Интеграция с Проводником Windows 10/11 (классическое меню)
Без COM-расширений: будем использовать реестр и статические подменю (old-style shell verbs) — это надежно, без DLL/COM и без админ-прав (HKCU).
Размещение ключей:
HKCU\Software\Classes\AllFilesystemObjects\shell\PContext — для файлов и папок
HKCU\Software\Classes\Directory\Background\shell\PContext — для клика по пустой области
При необходимости можно продублировать для специфических типов (например, .py), но лучше централизованно в AllFilesystemObjects и фильтровать появление пунктов.
Вложенные подменю: поддерживаются реестром через вложенные ключи shell. То есть PContext -> Analyze -> Анализировать делается как ...\PContext\shell\Analyze\shell\Анализировать\command.
Иконки в меню: у каждого элемента можно задать Icon = "C:\Users<user>.pcontext\icons<id>.ico".
Отбор по типам (Image, Video, DOC, …):
Используем свойство AppliesTo (property system) на уровнях команд для фильтрации видимости. Примеры: System.Kind:=picture, System.Kind:=video, System.FileExtension:=.jpg OR .png и т. п. Это хорошо ложится на ваши типы и комбинирование (Image | Video).
Для «множественных» типов (Images, Videos) и комбинаций через OR — AppliesTo умеет логические выражения.
Важно: при мультивыборе тонкий контроль «все элементы должны соответствовать» в чистом реестре ограничен; обычно показывается пункт, если хотя бы один матчится. Если нужно строго «все», логика может быть уже в рантайме (скрыть/сообщить пользователю).
Мультивыбор:
Параметр MultiSelectModel=Player на командах — Explorer передаст все выбранные пути в один запуск (вставит список аргументов вместо %1/%L). Это стандартный способ принимать сразу несколько выбранных объектов. Мы будем использовать %L (long path).
Передача путей:
В командах "...\command" используем что-то вроде: "C:\Path\to\pcontext.exe" run --id "<script-id>" --cwd "%V" %L
%L — список выбранных элементов (при MultiSelectModel=Player) или один элемент.
Для клика по пустой области используем "%V" как путь к текущей папке.
Производительность меню:
Так как меню статическое (через реестр), оно открывается мгновенно. Динамику (показ/скрытие по чекбоксу «показывать в контекстном меню») реализуем пересборкой/перерегистрацией ключей при обновлении.
Интеграция с Linux (Ubuntu)
Приоритет Windows, но планируем:
Nautilus (GNOME Files): Python-расширение через GObject (Nautilus.MenuProvider) — позволит динамически строить меню PContext с вложенными пунктами и фильтрами по типам и количеству. Это самый качественный вариант для GNOME.
Быстрый упрощенный старт — Nautilus Scripts (~/.local/share/nautilus/scripts), но они попадут в стандартное подменю "Scripts", а не "PContext". Лучше целиться в полноценный плагин.
Nemo/Thunar/Dolphin — отдельные бекенды позже (плагин API разные). На старте можно ограничиться Nautilus.
Архитектура приложения
Главный процесс PContext (с трей-иконкой):
Управляет реестром скриптов/сервисов и их состоянием.
Поднимает IPC-сервер (локальный, только для localhost) для команд: запуск oneshot, запуск/остановка сервисов, открытие Ask-окон, уведомлений, логирования.
Отвечает за UI: окна трея, списки процессов/сервисов/скриптов, формы параметров, логи.
Ведет реестр (SQLite + JSON манифесты) и кеш.
Запуск oneshot:
Отдельный процесс на каждый вызов (контролируемый таймаутом).
Он подключается к IPC, может запросить Ask, и по завершении возвращает Action.
Сервис:
Отдельный долгоживущий процесс с RPC. RPC — через тот же IPC-сервер в главном процессе или прямое соединение сервис <-> диспетчер.
Имеет idle-таймаут (max_downtime) и общий timeout, автоперезапуск по требованию.
Методы @service_script вызываются через брокер, который гарантирует запуск сервиса перед вызовом.
IPC:
Вариант 1: HTTP (aiohttp) на localhost с токеном и Unix domain socket/Named Pipe (Windows) — просто и надежно.
Вариант 2: ZeroMQ — очень быстрый, но добавляет зависимость.
Я бы начал с aiohttp + Unix socket/Named Pipe (скорость достаточная, интеграция простая).
Модель данных:
ScriptSpec (id, type: oneshot|service, group path, title, description, timeouts, requires_service?, parameters schema, inputs schema, visibility flags, autostart).
ParamSpec (type, default, constraints ge/le/choices, description).
ReturnAction: Open/Text/Link/Copy/Notify/Folder/None (+payload).
LogEntry: id, script_id, title, start_time, end_time, duration, status, action_snapshot (для повторения действия), error_message/error_trace.
Декораторы и API (ваша идея — удачная)
oneshot_script: регистрирует функцию, у которой параметры — это микс входов (File/Image/...) и Param-параметров. Возвращает Action или None.
service: декорирует класс. Параметры конструктора — конфиг сервиса (Param). Жизненный цикл управляется диспетчером.
service_script: метод сервиса, который работает как oneshot, но использует модель/ресурсы сервиса.
Ask(QuestionsClass): блокирующий вызов (через IPC), который открывает форму с типобезопасными полями.
Параметры:
Поддержка типов: str, int, float, bool, Enum, pathlib.Path (файл/папка), списки (множ. выбор), с валидацией ge/le/pattern/choices.
Значения сохраняются персистентно, кнопка «reset» возвращает к дефолтам.
Для сервисов: изменение параметров может требовать рестарт сервиса (предусмотреть опцию «применить и перезапустить»).
Входные типы (File/Folder/Image/Video/etc.) и их комбинации:
На уровне регистрации — сопоставим типы с AppliesTo (Windows) и с проверками в рантайме.
На уровне функции — строгая проверка типов и количества (один или несколько). При несоответствии — понятная ошибка/уведомление.
Управление зависимостями скриптов
Вверху файла — triple-quoted requirements (как requirements.txt).
Для изоляции и предотвращения конфликтов — отдельный venv на скрипт/сервис (C:\Users<user>.pcontext\envs<script_id>).
Установка через pip из созданного venv.
Кеширование pip (по умолчанию есть) для ускорения.
Опционально (позже) поддержать uv/pipx для ускорения.
Регистрация/обновление:
При сканировании скриптов — если deps изменились, предложить/выполнить обновление.
При первой регистрации — установка deps обязательна (прогресс-бар/логи).
Поскольку «пользователь доверяет скриптам», импорт во время сканирования допустим, но:
Явно попросим авторов не выполнять тяжелые операции на уровне модуля (всё тяжелое — в сервисе/init).
Сканирование делать в форкнутом процессе с таймаутом и ограниченными env переменными.
Регистрация/сканирование/идентификаторы
Скрипты: C:\Users<user>.pcontext\scripts (Windows), ~/.pcontext/scripts (Linux).
Иконки: C:\Users<user>.pcontext\icons<id>.ico (Windows). На Linux — .png/.svg с тем же именем.
Идентификаторы:
Если не указан — детерминированная генерация из относительного пути + имя объекта: напр. analyze.analyze (folder.file_or_class[.function]).
Для @service_script — id вида <service_id>.<method>.
Важно обеспечить стабильность id при переименовании title/description.
Группы в меню:
По структуре папок от корня scripts.
Опционально можно переопределить в декораторе (group=...).
Хранилище реестра скриптов: SQLite + JSON манифест (для быстрого старта), плюс кеш зависимостей.
Обновление («Обновить» в UI):
Рекурсивный обход scripts.
Установка новых deps, регистрация новых команд в реестре.
Если скрипт изменился — перерегистрация, сброс параметров (как вы хотите).
В фоне можно включить watchdog и автоссинхронизацию (опционально).
Выполнение, таймауты, ошибки
oneshot:
Процесс-воркер; жесткий таймаут.
Ошибки: отлавливаем, показываем Notify, пишем в логи, даем кнопку «Показать трассировку».
сервис:
Процесс; idle-таймер (max_downtime) останавливает при простое.
Общий таймаут lifetime — аварийно останавливаем (с уведомлением).
Healthcheck и мягкое завершение (del или явный shutdown hook).
Связь скрипт -> сервис:
Рантайм проверяет состояние, при необходимости стартует сервис, затем вызывает метод.
Ask:
Блокирует воркер до ответа.
Форма типобезопасная; подсветка ошибок валидации; поддержка сбора файлов/папок (диалог выбора), Enum — выпадающий список и т.д.
Возвращаемые действия:
Open: os.startfile (Windows) / xdg-open (Linux), либо конкретное приложение.
Link: webbrowser.open.
Copy: системный буфер + опциональный Notify.
Text: диалог с текстом и кнопкой «Копировать».
Folder: открыть проводник.
None: ничего.
Для логов сохраняем снапшот действия, чтобы «повтор» корректно работал.
Трей и UI
Технология: PySide6 (Qt 6). Красиво, быстро, нативные треи/уведомления. Хорошо пакуется в exe.
Меню трея:
Запущенные сервисы: таблица, кнопки «Остановить», «Перезапустить», описание, аптайм.
Процессы: текущие oneshot, кнопка «Остановить», таймеры.
Все скрипты и сервисы:
Кнопка «Обновить» (скан и перерегистрация).
Список: id, тип (oneshot/service), название, описание, чекбоксы «Показывать в меню» (по умолчанию — да), «Запускать при старте» (по умолчанию — нет и только для безвходных).
Кнопка «Параметры»: открывает форму редактирования с Persist и Reset.
Кнопка «Запустить» (если не требует входных файлов).
Настройки:
Автозапуск PContext при входе в систему (реестр Run, либо ярлык в автозагрузке).
Глобально отключить нотификации.
Логи: последние N запусков, фильтры, статус, кнопка «Повторить действие».
Выход: останавливаем все сервисы и выходим.
Performance:
Главный процесс постоянно живет (быстрый отклик).
Отрисовка на Qt — отзывчивая. Аккуратно с блокировками, все длительные операции в потоках/процессах.
Сборка и дистрибуция
Windows: PyInstaller (one-dir лучше, чем one-file, ради скорости старта и работы с venv’ами; one-file возможен, но медленнее и сложнее с вложенными питонами).
Внутри поставки — собственный python.exe для PContext. Venv для скриптов создается отдельно.
Обновления PContext: автопроверка и обновление
