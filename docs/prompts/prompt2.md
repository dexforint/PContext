Я хочу реализовать библиотеку (программау) под названием PContext на Python для windows 10/11 (в приоритете) и Linux (Ubuntu), которая бы позволяла вставлять Python скрипты в контекстное меню (нажатие правой кнопки мыши на файле/файлах/папке/папках, либо в пустой области). Это должно примерно так: пользователь пишет свой скрипт, перемещает в определённую папку, где библиотека может найти этот файл, запускает регистрацию скриптов из меню библиотеки, чтобы библиотека зарегистрировала данный скрипт, и теперь данный скрипт может выполняться при вызове контекстного меню (на определённых файлах).

Примечания:

- все скрипты могут быть либо одноразовыми - служат для выполнения задачи единоразово, либо сервисами - инициализирует модели и предоставляют их по запросу.
- скрипты в контекстном меню должны находиться не в главном констекстном меню, а в подменю "PContext"
- скрипты могут быть сгруппированы: группировка происходит с помощью папок. Например, если в главной папке скриптов есть папка "Analyze", в ней есть файл "analyze.py", а в ней, в свою очередь, есть обрамлённая в oneshot функция с title = "Анализировать", то данный скрипт в контекстном меню будет иметь путь: PContext -> Analyze -> Анализировать
- у скриптов могут быть параметры, которые можно менять. Эти параметры (их типы, диапозоны и значения по-умолчанию) должны быть указаны в декораторе скрипта. Менять можно через меню.
- у запущенной программы (библиотеки) должен быть tray icon, с помощью которого можно открыть меню программы (смотри ниже). Tray Icon должен обязательно показываться пока программа запущена.
- UI выбираешь сам, главное, чтобы оно было быстрым и красивым.
- Python-версия: ≥ 3.10
- Считаем, что пользователь доверяет своим скриптам
- В начале скрипта может присутствовать строка (с тройными кавычками), которая представляет собой необходимые для установки зависимости (кроме самого pcontext) для данного скрипта (как в requirements.txt). При регистрации скрипта эти зависимости должны устанавливаться.
- при возникновении ошибки в скрипте они должны обрабатываться программы, которая должна уведомлять пользователя об ошибке.
- место хранения скриптов на windows: `C:\Users\<user>\.pcontext\scripts`, место для хранения иконок .ico для скриптов: `C:\Users\<user>\.pcontext\icons`. Имя иконки скрипта соответствует id скрипта, например: `yolo_service.ico`
- Для Windows 11: я отключил новое контекстное меню, теперь оно у меня как в windows 10 - делать PContext нужно для него.
- Хотелось бы данную программа скомпилировать в полноценный exe (windows) файл
- Сама программа должна быть оптимизирована и выполняться быстро
- Если вызывается скрипт, которому необходим запущенный сервис (например, скрипту "yolo_service.detect" необходим сервис "yolo_service"), в таком случае запускается сервис "yolo_service", если он не запущен, а затем выполняется скрипт "yolo_service.detect"

Меню tray (открывается нажатием правой кнопкий мыши по иконке трея):

- "Запущенные сервисы" - открывает окно с запущенными сервисами, в котором есть возможность остановить их;
- "Процессы" - открывает окно с работающими в данный момент скриптами (oneshot), в котором есть возможность остановить их;
- "Все скрипты и сервисы" - открывает окно со всеми скриптами и сервисами. В данном окне:

  - кнопка "Обновить" - анализирует папку со скриптами. Если нашлись новые - регистрирует их и показывает здесь. Если нашлись изменения в старых - то перерегистрирует данный скрипт и обновляет (ресет) его параметры;
  - список со всеми сервисами и скриптами;
  - каждый пункт списка обозначает:

    - id скрипта
    - является ли данный скрипт oneshot или service
    - название скрипта (сервиса)
    - описание
    - чек-бокс, которые обозначает: показывать ли данный скрипт (сервис) в контекстном меню. По умолчанию стоит
    - чек-бокс, которые обозначает: запускать ли данный скрипт (сервис) при запуске программы. По умолчанию не стоит. Данный чек-бокс должен работать только для тех сервисов и скриптов, которые не требуют входных файлов.
    - кнопка, которая открывает окно для настройки значений параметров скрипта. Изменения значений должны сохраняться между перезапусками программы (и компьютера). В этом окне должна быть кнопка ресета значений. Окно должно быть похоже на окно для Ask (смотри ниже).
    - кнопка для запуска скрипта (сервиса). Присутствует, только если скрипт (сервис) не требует входных файлов.

- "Настройки" - окно с настройками программы:
  - возможность запускать программу при запуске компьютера;
  - возможность насильно отключить уведомления (игнорирование Notify)
- "Логи" - окно с логами. В данном окне отображаются последние запуски скриптов с обозначением:
  - ID запуска;
  - Имя скрипта;
  - Время запуска;
  - Длительность выполнения;
  - Статус (успех/ошибка)
  - Кнопка, повторяющее действие выхода скрипта (если скрипт завершился успешно). То есть, если скрипт возвратил `Open("<path-to-file")`, то при нажатии этой кнопки действие повторяется с такими же параметрами. Если при выполнении действия произошла ошибка (файла больше не существует, например), то пользователь информируется об этом;
- "Выход" - при нажатии программа закрывается (тогда все скрипты и сервисы остановятся);

Типы входных файлов (можно расширять):

- File - любой файл
- Folder - папка
- Image - изображение
- Video - видео
- TXT - файлы, которые могут читаться в Блокноте (.txt, .yaml, )
- DOC - документ (pdf, docx, ...)
- ARCHIVE - архив (zip, 7z, ...)
- PYTHON - Py-файлы
- EXE - выполняемые файлы

- А так же: Images, Videos, TXTs, DOCs, ... - множественный выбор
- Типы можно объединять, например: `Image | Video` - либо изображение, либо видео
- Extensions(extensions) - выбор расширений вручную, например: `Extensions(["jpg", "png"])` - либо jpg изображения, либо png изображения.

Типы возвращаемых действий:

- Open - открыть файл в приложении; Имеет два параметра:
  - path - путь к файлу;
  - app - путь до приложения, которое будет открывать файл. Если - None (по умолчанию), то файл откроется в приложении по умолчанию, исходя из расширения файла.
- Text - вывести текст в отдельном окне. В этом окне должна быть кнопка "Копировать", которая копирует текст в буфер обмена;
- Link - открыть ссылку в браузере по умолчанию;
- Copy - скопировать текст в буфер обмена. Параметры text и notification (по умолчанию - None) - нативное уведомление.
- Notify - уведомить пользователя нативным уведомлением. Входные параметры: title и description;
- Folder - открыть папку;
- None - ничего не делать;

Есть также специальное действие Ask (не является возвращаемым действием), которое вызывает окно, в котором пользователь должен дать ответы на поставленные вопросы. На вход принимает класс с аннотированными полями. Для каждого типа данных хотелось бы иметь собственное поле ввода с проверкой типов данных. Например для `str` можно вводить любой текст в поле, для `int` - целочисленные числа, для `float` - числа с плавающей запятой, для Enum - выпадающий список и так далее.

Пример простого скрипта:

```python
"""
requests>=2.28
"""
import os
from enum import Enum
import requests
from pcontext import oneshot_script, File, Param
from pcontext.actions import Copy

def get_file_size_mb(file_path: str):
    """
    Возвращает размер файла в мегабайтах (МБ).
    """
    # Получаем размер файла в байтах
    size_in_bytes = os.path.getsize(file_path)

    # Конвертируем байты в мегабайты
    # 1 МБ = 1024 КБ = 1024 * 1024 Байт
    size_in_mb = size_in_bytes / (1024 * 1024)

    return size_in_mb


class ServerURL(str, Enum):
    tempsh = "https://temp.sh/upload"
    tmpfiles = "https://tmpfiles.org/api/v1/upload"

@oneshot_script(
    # если id не указан, то он генерится автоматически
    # Название в пункте контекстного меню
    title="Upload to temp.sh",
    description="Скрипт загружает выбранный файл (<4Гб) на облачный сервер"
    # Максимальное время выполнения в секундах
    timeout=60,
)
def upload_file(
        # указываем, что для любых файлов мы можем вызвать в контекстом меню данную функцию
        # получаем путь до файла
        file_path: str = File(),
        # далее идёт параметр, чьё значение можно менять в трее
        server_url: ServerURL = Param(default="https://temp.sh/upload")
    ):
        file_size = get_file_size_mb(file_path)

        if file_size > (1024 * 4):
            raise RuntimeError(
                "Файл превышает лимит 4 ГБ и не будет загружен!"
            )

        files = {
            'file': open(file_path, 'rb'),
        }

        response = requests.post(server_url, files=files)

        if response.ok:
            return Copy(
                response.text,
                notification="Файл загружен! Ссылка скопирована в буфер обмена!"
            )
        else:
            return Notify(
                "Произошла ошибка во время загрузки!"
            )
```

Пример сервиса:

```python
"""
ultralytics
"""
from enum import Enum
from pathlib import Path
import tempfile
from ultralytics import YOLO
from pcontext import service_script, service, Image, Param
from pcontext.actions import Open

class ModelName(str, Enum):
    yolov8n = "yolov8n.pt"
    yolov8s = "yolov8s.pt"

@service(
    id="yolo_service",
    title="Запустить Yolo детектор",
    description="Данный сервис служит для обслуживания модели детектора объектов на изображениях Yolo.
    # максимальное время работы сервиса, если это время превышено, то сервис останавливается
    timeout=3600,
    # максимальное время простоя без дела, если это время превышено, то сервис останавливается
    max_downtime=600,
    # данный параметр автоматически запускает сервис при запуске программы. Данное поведение можно изменить в настройках сервиса.
    on_startup=True # по умолчанию - False
)
class YoloDetector:
    # для подачи входных файлов и параметров в service используется __init__ класса сервиса
    def __init__(
        self,
        # указываем параметр
        model_name: ModelName = Param("yolov8n.pt")
    ):
        self.device = "cuda" if torch.cuda.is_available() else "cpu"
        self.model = YOLO(model_name)
        # Перемещаем модель на выбранное устройство
        self.model.to(self.device)

    @service_script(
        id="yolo_service.detect"
        # Название в пункте контекстного меню
        title="Задетектировать объекты",
        # Максимальное время выполнения в секундах
        timeout=10,
    )
    def detect(
        self,
        # даём понять, что на вход ожидаем путь до изображения
        image_path: str = Image,
        # указываем параметр с диапозоном значений
        conf_threshold: float = Param(
            0.4,
            ge=0.0, # минимальное значение
            le=1.0, # максимальное значение
        )
    ):

        results = self.model.predict(source=image_path, conf=conf_threshold, verbose=False)
        result = results[0]
        im_array = result.plot()

        with tempfile.TemporaryDirectory() as temp_dir:
            file_path = Path(temp_dir) / "my_temp_file.png"
            cv2.imwrite(file_path, im_array)

        return Open(file_path)

    def __del__(self):
        """
        Освобождает ресурсы при удалении объекта класса (при завершении сервиса).
        """
        del self.model
        if self.device == 'cuda':
            # Очень важный шаг для освобождения VRAM
            torch.cuda.empty_cache()
        # Принудительно вызываем сборщик мусора
        gc.collect()
```

Пример с Ask:

```python
import os
from enum import Enum
from typing import Annotated
from pcontext import oneshot_script, Image
from pcontext.questions import Ask, Questions, Question, ImageQuery
from pcontext.actions import Text

class Gender(str, Enum):
    male = "Male"
    female = "Female"

class UserQuestions(Questions):
    name: Annotated[str, "Имя пользователя"] = "user"
    age: Annotated[int, Question(description="Возраст пользователя", ge=18, le=100)]
    gender: Annotated[Gender, "Пол пользователя"]
    # следующее поле представляет собой запрос изображения (пути к изображению) на компьютере
    # на windows, например, должно открыться специальное окно
    photo: Annotate[str, Question(format=ImageQuery, description="Фото пользователя")]

@oneshot_script(
    title="Сформировать текст",
    description="По ответам пользоваля формирует текст."
)
def make_text():
    # при выполнении этой строки открывается окно, в котором пользователю необходимо ввести ответы на вопросы из Questions
    # при этом выполнение дальнейшего кода не происходит, пока пользователь не ответит на вопросы (или закроет окно)
    answers = Ask(UserQuestions)

    if answers is None: # пользователь закрыл окно
        raise RuntimeError(
            "Ответы на вопросы не получены!"
        )

    text = f"Пользователь ввёл:\n\nИмя: {answers.name}\nВозраст: {answers.age}\nПол: {answers.gender}\nПуть до фото: {answers.photo}"

    return Text(
        text
    )
```

При написании примеров я вдохновлялся синтаксисом библиотеки FastAPI и Pydantic.

Пока не пиши код, а тщательно продумай решение.
Я жду твои очень понятно разъяснённые мысли, замечания, советы, улучшения. Всё ли тебе нравится в моём описании проекта и примерах? Или можно улучшить?
Не стесняйся задавать вопросы, если они есть. Я хочу, чтобы не было белых пятен перед разработкой программы.

---

Теперь давай перейдём к реализации: тщательно продумай архитектуру проекта и напиши его структуру
